<link rel="import" href="sugar_task_list_item.html">

<dom-module id="sugar-task-list">
  <template>
    <h2>Tasks (current)</h2>
    <ul>
      <template is="dom-repeat"
                items="{{tasks}}"
                filter="isIncompleteCurrent_"
                sort="taskCompare_"
                observe="status scheduledTime deadlineTime">
        <li><sugar-task-list-item task="{{item}}"></sugar-task-list-item></li>
      </template>
    </ul>

    <h2>Tasks (future)</h2>
    <ul>
      <template is="dom-repeat"
                items="{{tasks}}"
                filter="isIncompleteFuture_"
                sort="taskCompare_"
                observe="status scheduledTime deadlineTime">
        <li><sugar-task-list-item task="{{item}}"></sugar-task-list-item></li>
      </template>
    </ul>

    <h2>Tasks (completed)</h2>
    <ul>
      <template is="dom-repeat"
                items="{{tasks}}"
                filter="isComplete_"
                sort="taskCompare_"
                observe="status scheduledTime deadlineTime">
        <li><sugar-task-list-item task="{{item}}"></sugar-task-list-item></li>
      </template>
    </ul>
  </template>
  <script>
Polymer({
  is: 'sugar-task-list',

  properties: {
    tasks: Array
  },

  isIncomplete_: function(task) {
    return task.status === '' || task.status === 'todo' ||
        task.status === 'waiting';
  },

  isIncompleteCurrent_: function(task) {
    return this.isIncomplete_(task) &&
        this.getEarliestTaskTime_(task) <= Date.now();
  },

  isIncompleteFuture_: function(task) {
    return this.isIncomplete_(task) &&
        this.getEarliestTaskTime_(task) > Date.now();
  },

  isComplete_: function(task) {
    return task.status === 'done';
  },

  /**
   * Compare function that determines the order of tasks in the list.
   *
   * Tasks are currently ordered in ascending order by the time at which they
   * become applicable (the minimum of the scheduled time and the deadline
   * time).
   */
  taskCompare_: function(task1, task2) {
    return this.getEarliestTaskTime_(task1) - this.getEarliestTaskTime_(task2);
  },

  /**
   * Returns the earliest time applicable to the task. If any time is unset,
   * it's treated as Infinity.
   */
  getEarliestTaskTime_: function(task) {
    var taskScheduledTime = task.scheduledTime || Infinity;
    var taskDeadlineTime = task.deadlineTime || Infinity;
    return Math.min(taskScheduledTime, taskDeadlineTime);
  }
});
</script>
</dom-module>
