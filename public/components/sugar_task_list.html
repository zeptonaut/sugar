<link rel="import" href="../bower_components/paper-material/paper-material.html">
<link rel="import" href="../bower_components/paper-styles/typography.html">
<link rel="import" href="sugar_task_list_item.html">

<dom-module id="sugar-task-list">
  <template>
    <style is="custom-style">
    h2 {
      @apply(--paper-font-subhead);
      font-weight: bold;
      color: #212121;
      font-size: 0.9rem;
      line-height: 1.8rem;
    }
    paper-material {
      background: #fff;
      max-width: 800px;
    }
    </style>
    <h2>Tasks (today)</h2>
    <paper-material elevation="2">
      <ul>
        <template is="dom-repeat"
                  items="{{tasks}}"
                  filter="isIncompleteCurrent_"
                  sort="taskCompare_"
                  observe="status scheduledTime deadlineTime">
          <li class="task"><sugar-task-list-item task="{{item}}"></sugar-task-list-item></li>
        </template>
      </ul>
    </paper-material>
    <h2>Tasks (future)</h2>
    <paper-material elevation="2">
      <ul>

        <template is="dom-repeat"
                  items="{{tasks}}"
                  filter="isIncompleteFuture_"
                  sort="taskCompare_"
                  observe="status scheduledTime deadlineTime">
          <li><sugar-task-list-item task="{{item}}"></sugar-task-list-item></li>
        </template>
      </ul>
    </paper-material>
    <h2>Tasks (completed)</h2>
    <paper-material elevation="2">
      <ul>
        <template is="dom-repeat"
                  items="{{tasks}}"
                  filter="isComplete_"
                  sort="taskCompare_"
                  observe="status scheduledTime deadlineTime">
          <li><sugar-task-list-item task="{{item}}"></sugar-task-list-item></li>
        </template>
      </ul>
    </paper-material>
  </template>
  <script>
Polymer({
  is: 'sugar-task-list',

  properties: {
    tasks: Array
  },

  isIncomplete_: function(task) {
    return task.status === '' || task.status === 'todo' ||
        task.status === 'waiting';
  },

  isIncompleteCurrent_: function(task) {
    return this.isIncomplete_(task) &&
        this.getEarliestTaskTime_(task) <= Date.now();
  },

  isIncompleteFuture_: function(task) {
    return this.isIncomplete_(task) &&
        this.getEarliestTaskTime_(task) > Date.now();
  },

  isComplete_: function(task) {
    return task.status === 'done';
  },

  /**
   * Compare function that determines the order of tasks in the list.
   *
   * Tasks are currently ordered in ascending order by the time at which they
   * become applicable (the minimum of the scheduled time and the deadline
   * time).
   */
  taskCompare_: function(task1, task2) {
    return this.getEarliestTaskTime_(task1) - this.getEarliestTaskTime_(task2);
  },

  /**
   * Returns the earliest time applicable to the task. If any time is unset,
   * it's treated as Infinity.
   */
  getEarliestTaskTime_: function(task) {
    var taskScheduledTime = task.scheduledTime || Infinity;
    var taskDeadlineTime = task.deadlineTime || Infinity;
    return Math.min(taskScheduledTime, taskDeadlineTime);
  }
});
</script>
</dom-module>
